\centerline{Validieren}

\bigskip

\begin{itemize}

\item Das Ziel von Validieren ist es, die Qualit\"at des Software vom
Blickwinkel des Benutzers zu beurteilen; z.B. Zuverl\"assigkeit.

\item Ziel aller Validierungstechniken ist es,

\begin{itemize}
\item Fehlverhalten zu entdecken
\item die urs\"achlichen Fehler zu lokalisieren
\item (letzendlich die Fehler zu beheben)
\end{itemize}

und damit ein m\"oglichst hohes Vertrauen zu schaffen, da{\ss} die
Komponente sich entsprechend der Spezifikation verh\"alt.

\end{itemize}



\newpage
\centerline{Verschiedene Techniken}
\bigskip


\begin{list}{$\bullet$}{\labelwidth=1.5cm\leftmargin=\labelwidth}

\item[(A)] Ausf\"uhrungs-basiert (Testen)

\begin{list}{$\bullet$}{\labelwidth=1.5cm\leftmargin=\labelwidth}

\item [(A1)] Black-box (funktionales Testen)

\begin{list}{$\bullet$}{\labelwidth=1.5cm\leftmargin=\labelwidth}
\item[(A11)] \"Aquivalenzklassen-basiert
\item[(A12)] Grenzfall-basiert

\end{list}

\item[(A2)] White-box (strukturelles Testen)

\begin{list}{$\bullet$}{\labelwidth=1.5cm\leftmargin=\labelwidth}
\item[(A21)] Anweisungs-\"Uberdeckung
\item[(A22)] Kontrollpfad-\"Uberdeckung
\item[(A23)] Kontrollkanten-\"Uberdeckung

(usw.)
\end{list}

\end{list}

\item [(B)] Nicht ausf\"uhrungs-basiert (Lesen)

\begin{list}{$\bullet$}{\labelwidth=1.5cm\leftmargin=\labelwidth}
\item [(B1)] symbolische Ausf\"uhrung
\item [(B2)] Lesen

\begin{list}{$\bullet$}{\labelwidth=1.5cm\leftmargin=\labelwidth}
\item[(B21)] sequentiell
\item[(B22)] kontrollflu{\ss}orientiert
\item[(B23)] schrittweise Abstraktion
\end{list}

\end{list}

\end{list}

\newpage

\centerline{Testen}  

\bigskip

Ziel: Eine endliche Menge T von Tests (T $\subseteq$ input x output)
zu bestimmen, so da{\ss} 
\begin{enumerate}
\item die Wahrscheinlichkeit hoch ist, alle Fehler offenzulegen
\item das Vertrauen hoch ist, da{\ss} alle Fehler offengelegt sind.
\end{enumerate}

Es gibt unterschiedliche Kriterien
\begin{itemize}
\item f\"ur die Auswahl von Tests
\item f\"ur die Entscheidung \"uber die ``Vollst\"andigkeit'' von
Tests (oder Testterminierung)
\end{itemize}

Jeder Test ist spezifiziert durch ein Paar T$_i$:(TF, TD), wobei
\begin{itemize}

\item TF den Testfall repr\"asentiert

(d.h., eine m\"ogliche Sequenz von Aufrufen der Komponente)

\item TD die Testdaten repr\"asentiert

(d.h., Paare (i $\in$ input, o $\in$ output))

Bem.: o beschreibt das entsprechend der Spezifikation erwartete
Ergebnis f\"ur Eingabe i.

\end{itemize}


\newpage
\centerline{Testen Kontinuert}
\bigskip

Testergebnisse

\begin{itemize}

\item $T_i$: ($o \in$ output, $o' \in$ [Pgm](i))

\item $o$: erwartete Ausgabe

\item $o'$: tats\"achliche Ausgabe

\end{itemize}


Dokumentation:
\begin{itemize}

\item T$_1$: Kommentar (``Zweck des Tests'')
\subitem Testfall: $f_1$
\subitem Testdaten (Eingabe, erwartete Ausgabe)
\subitem Testergebnis (tats\"achliche Ausgabe)
\subitem Diagnose
\end{itemize}

Myers: Ein erfolgreicher Testfall f\"uhrt zu einem Fehlverhalten!


\newpage
\centerline{Black-Box Testen}

\bigskip

Beispiel:
\begin{tabbing}
$ (x \ne 0 \rightarrow $ \= $( z > 1 \rightarrow y, z := 5, z/x \,|\, y, z := 5,0) \,|\,$ \\
                         \> $( z > 1 \rightarrow z := (z-x) / x \,|\, z := 0))$ \\
\end{tabbing}

Testdaten Entwicklen

\begin{enumerate}

\item[1.] \"Aquivalenzklassen identifizieren

Unterteilung des Inputs in \"Aquivalenzklassen, von denen gleiches
Verhalten erwartet wird.
\begin{enumerate}
\item $x \ne 0 \wedge z >    1$
\item $x \ne 0 \wedge z \leq 1$
\item $x  =  0 \wedge z >    1$
\item $x  =  0 \wedge z \leq 1$
\end{enumerate}

\end{enumerate}

\newpage
\centerline{Black-Box Testen Kontinuiert}

\bigskip

Testdaten Entwickeln kontinuiert:

\begin{enumerate}

\item[2.] Testf\"alle aussuchen

\begin{itemize}
\item \"Aquivalenzklassen-basiert

ein (oder mehrere) Test pro \"Aquivalenzklasse:

\{(x=1, z=4), (x=1,z=0), (z=0,z=4), (x=0,z=0)\}

\item Grenzfall-basiert

besondere Behandlung von Grenzf\"allen (d.h., Grenzen der
\"Aquivalenzklassen): 


\begin{enumerate}
\item \{($-\infty$,inc(1)),($+\infty$,inc(1)),($-\infty,+\infty$),($+\infty,+\infty$)\}
\item \{($-\infty$,1),($+\infty$,1),($-\infty,-\infty$),($+\infty,-\infty$)\}
\item \{(0, inc(1)), (0, $+\infty$)\}
\item \{(o, 1), (0, $-\infty$)\}

\end{enumerate}

Bem.: $+/-\infty$ entspricht der gr\"o{\ss}ten/kleinsten darstellbaren
Zahl, inc(x) der kleinsten darstellbaren Zahl gr\"o{\ss}er als x.


\end{itemize}

\end{enumerate}


\newpage
\centerline{Grunds\"atze des Prozesses: Black-Box}
\bigskip

\begin{enumerate}
\item Entdecken von Fehlverhalten

\begin{itemize}

\item Bestimme die Tests (TF, TD) anhand der Komponenten-Spezifikation
\begin{itemize}
\item identifiziere Testf\"alle
\item identifiziere Testdaten
\end{itemize}

Vollst\"andigkeitskriterien sind:
\begin{itemize}
\item entsprechend des \"Aquivalenzklassen-basierten Ansatzes, da{\ss}
f\"ur jede Klasse zumindest ein Test vorliegt.
\item entsprechend des Grenzfall-basierten Ansatzes, da{\ss} aus der
Umgebung jeder Unstetigkeit zumindest ein Test vorliegt.

\end{itemize}

\item F\"ur den Eingabeteil eines jeden Tests wird das Programm
ausgef\"uhrt (und dabei ein tats\"achlicher Ausgabewert erzielt).

\item Durch Vergleich der erwarteten Ausgabe mit der tats\"achlich
erzielten Ausgabe werden Fehlverhalten diagnostiziert.

\end{itemize} 

\item Lokalisieren von Fehlern
\begin{itemize}
\item f\"ur entdeckte Fehlverhalten die Ursache (d.h., den Fehler im
Kode suchen (Lesen und/order Debuggen)).
\end{itemize}

\end{enumerate}


\newpage
\centerline{Ben\"otigte Dokumente: Black-Box}
\bigskip

\begin{center}
\begin{tabular}{|l||c|c|c|}
\hline
               & Spezifikation & Quell-Kode  & ausf\"uhrbare\\
Schritte       &     $f$       & $pgm$       & Komponente\\
\hline
\hline
Testf\"alle      &               &             &       \\
generieren       &      X        &             &       \\
                 &               &             &       \\
\hline
Testf\"alle      &               &             &       \\
durchf\"uhren    &               &             &     X \\
                 &               &             &       \\
\hline
                 &               &             &       \\
Diagnose         &      X        &             &     X \\
                 &               &             &       \\
\hline
Lokalisieren     &               &             &       \\
der Fehler       &      X        &      X      &    X  \\
                 &               &             &       \\
\hline
\end{tabular}
\end{center}





\newpage
\centerline{White-Box Testen}

\bigskip

\begin{minipage}[b]{8cm}
\begin{verbatim}
01:  if x != 0 then
02:      y := 5;
03:  else
04:      z := z - x;
05:  endif
06:  if z > 1 then
07:      z := z / x;
08:  else
09:      z := 0;
10:  endif
\end{verbatim}
\end{minipage}
\includegraphics[scale=1]{white-box} 


\newpage
\centerline{White-Box Testen Kontinuiert}

\bigskip

Testdaten (f\"ur Quell-Kode)

\begin{enumerate}

\item Anweisungs-\"Uberdeckung

Auswahl von Tests, um jede Anweisung zumindest einmal auszuf\"uhren.

\{(x=0, z=1), (x=1, z=3)\}

\item Kontrollkanten-\"Uberdeckung

Auswahl von Testdaten, um jede Kante des Kontrollflu{\ss}graphen
zumindest einmal entlangzulaufen.

\{(x=0, z=1), (x=1, z=3)\}

\item vollst\"andige Kontrollpfad-\"Uberdeckung

Auswahl von Testdaten, um jeden elementaren Pfad zumindest eimal
auszuf\"uhren. 

\{(x=0, z=1), (x=1, z=3), (x=0, z=3), (x=1, z=1)\}

\end{enumerate}

\newpage
\centerline{Verfeinerung von \"Uberdeckungskriterien}
\bigskip

Sog. ``multiple-condition''-\"Uberdeckung

\begin{itemize}

\item Im Falle von kombinierten Boole'sche Bedingungen

(z.B. a $\wedge$ b), alle F\"alle m\"ussen abgedeckt werden:

\begin{center}
\begin{tabular}{p{2cm}|p{2cm}||p{2cm}}
\hline
a & b & a$\wedge$b \\
\hline
\hline
t & t & t \\
t & f & f\\
f & t & f\\
f & f & f\\
\hline
\end{tabular}
\end{center}

\item Im Falle von Vergleichsoperatoren (z.B. a $\leq$ b), 
beide M\"oglichkeiten m\"ussen abgedeckt werden (a = b, a $<$ b).

\item Im Falle von Schleifen (z.B. while $<$expr$>$ do S end),
die Schleife mu{\ss} 0, 1, und $>$ 1 mal ausgef\"uhrt werden.

\end{itemize}

\newpage
\centerline{Grunds\"atze des Prozesses: White-Box}
\bigskip

\begin{enumerate}

\item Entdecken von Fehlverhalten

\begin{itemize}

\item Bestimme die Tests (TF, TD) anhand des Quell-Kodes
\begin{itemize}
\item identifiziere Testf\"alle
\item identifiziere Testdaten
\end{itemize}

Vollst\"andigkeitskriterien sind

\begin{itemize}
\item entsprechend des Anweisungs-\"Uberdeckungs-Ansatzes:

(\# XEQ Anweisungen / \# vorhandene Anweisungen ) =  1

\item entsprechend des Kontrollpfad-\"Uberdeckungs-Ansatzes:

(\# XEQ Pfade / \# vorhandene Pfade ) = 1

$\mu$(G) := \# Kanten -- \# Knoten + 2

\end{itemize}

\item F\"ur den Eingabeteil eines jeden Tests wird das Programm
ausgef\"uhrt (und dabei ein tats\"achlicher Ausgabewert erzielt)

\item Durch Vergleich der erwartete Ausgabe mit der tats\"achlich
erzielten Ausgabe werden Fehlverhalten diagnostiziert.

\item erzielte \"Uberdeckungswerte werden mit Hilfe eines
Unterst\"utzungswerkzeugs gemessen.

\end{itemize}


\item Lokalisieren von Fehlern

\begin{itemize}

\item f\"ur entdeckte Fehlverhalten die Ursache (d.h., den Fehler im
Kode suchen (Lesen und/oder Debuggen)).

\end{itemize}

\end{enumerate}

\newpage
\centerline{Ben\"otigte Dokumente: White-Box Testen}
\bigskip

\begin{center}
\begin{tabular}{|l||c|c|c|}
\hline
               & Spezifikation & Quell-Kode  & ausf\"uhrbare\\
Schritte       &     $f$       & $pgm$       & Komponente\\
\hline
\hline
Testf\"alle      &               &             &       \\
generieren       &               &     X       &       \\
                 &               &             &       \\
\hline
Testf\"alle      &               &             &       \\
durchf\"uhren    &               &     (X)     &     X \\
                 &               &             &       \\
\hline
                 &               &             &       \\
Diagnose         &      X        &     (X)     &     X \\
                 &               &             &       \\
\hline
Lokalisieren     &               &             &       \\
der Fehler       &      X        &      X      &    X  \\
                 &               &             &       \\
\hline
\end{tabular}
\end{center}


\newpage
\centerline{Lesen durch schrittweise Abstraktion}

\bigskip


Beispiel:

\begin{verbatim}
01:  if x != 0 then
02:      y := 5;
03:  else
04:      z := z - x;
05:  endif
06:  if z > 1 then
07:      z := z / x;
08:  else
09:      z := 0;
10:  endif
\end{verbatim}

\"Ubersichtliche Dokumentation:

\bigskip

Zeilen 01--05:  

\(x \ne 0 \rightarrow y := 5 \,|\, z := z - x\)

\bigskip

Zeilen 06--10:  

\(z > 1 \rightarrow z := z / x \,|\, z := 0\)

\bigskip

Abstraktion lines 01--10:
\begin{tabbing}
$ (x \ne 0 \rightarrow $ \= $( z > 1 \rightarrow y, z := 5, z/x \,|\, y, z := 5,0) \,|\,$ \\
                         \> $( z > 1 \rightarrow z := (z-x) / x \,|\, z := 0))$ \\
\end{tabbing}


\newpage
\centerline{Grunds\"atze des Prozesses}
\bigskip

\begin{enumerate}

\item Entdecken von Fehlverhalten

\begin{itemize}

\item durch Lesen die Bedeutung einer Komponente bestimen.

$\rightarrow [pgm]$

\begin{itemize}

\item bestimme die Bedeutungsfunktion jedes elementaren Programmteils
und beschreibe sie in Form eine bedingten Anweisung.

Bem.: Bedingungen sowie parallele Anweisungen sollten so formal wie
m\"oglich beschrieben werden.

\item Aggregiere diese elementaren Funktionen entsprechend des
Kontrollflusses. 

\end{itemize}

\item vergleiche die abstrahierte Bedeutungsfunktion mit der
vorgegebenen Spezifikation, um m\"ogliche Fehlverhalten zu
diagnostizieren. 

$\rightarrow$ ist $ f \subseteq [pgm]$ ?

Bem.: Falls Spezifikationen einzelner Entwurfsteile existieren, 
so kann die Diagnose schrittweise erfolgen.

\end{itemize}

\item Lokalisieren von Fehlern

\begin{itemize}

\item f\"ur entdeckte Fehlverhalten die Ursache (d.h. Fehler) im Kode
suchen. 

Bem.: Das Verst\"andnis des Kodes durch das vorangegangene Lesen
sollte die Lokalisierung erleichtern.

\end{itemize}


\end{enumerate}

\newpage
\centerline{Ben\"otigte Dokumente: Lesen}
\bigskip

\begin{center}
\begin{tabular}{|l||c|c|c|}
\hline
               & Spezifikation & Quell-Kode  & ausf\"uhrbare\\
Schritte       &     $f$       & $pgm$       & Komponente\\
\hline
\hline
Entdecken von  &             &             &      \\
Fehlverhalten  &               &      X      &      \\
($\rightarrow [pgm]$) &        &             &      \\
\hline
Vergleich      &               &             &      \\
($f\subseteq [pgm]?)$&   x     &      X      &      \\
               &               &             &      \\
\hline
Lokalisieren   &             &             &      \\
der Fehler     &      X        &      X      &      \\
               &               &             &      \\
\hline
\end{tabular}
\end{center}
